<?php

namespace Modules\TripManagement\Repositories;

use Carbon\Carbon;
use Illuminate\Database\Eloquent\Collection;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Pagination\LengthAwarePaginator;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Schema;
use MatanYadaev\EloquentSpatial\Objects\Point;
use Modules\TripManagement\Entities\TripRequest;
use Modules\TripManagement\Interfaces\TripRequestInterfaces;

class TripRequestRepository implements TripRequestInterfaces
{
    public function __construct(
        private TripRequest $trip
    ) {}

    /**
     * @param int $limit
     * @param int $offset
     * @param bool $dynamic_page
     * @param array $except
     * @param array $attributes
     * @param array $relations
     * @return LengthAwarePaginator|array|Collection
     */
    public function get(
        int $limit,
        int $offset,
        bool $dynamic_page = false,
        array $except = [],
        array $attributes = [],
        array $relations = []
    ): LengthAwarePaginator|array|Collection {
        $search = $attributes['search'] ?? null;
        $extraColumn = $attributes['column_name'] ?? null;
        $extraColumnValue = $attributes['column_value'] ?? null;
        $queryParams = ['search' => $search];

        $query = $this->trip
            ->query()
            ->when($search, function ($query) use ($search) {
                $query->where(function ($query) use ($search) {
                    $keys = explode(' ', $search);
                    foreach ($keys as $key) {
                        $query->where('ref_id', 'like', '%' . $key . '%');
                    }
                });
            })
            ->when(($attributes['relations'] ?? null), fn($query) => $query->with($attributes['relations']))
            ->when(!empty($relations), fn($query) => $query->with($relations))
            ->when($attributes['from'] ?? null, fn($query) => $query->whereBetween('created_at', [$attributes['from'], $attributes['to']]))
            ->when($attributes['column'] ?? null, fn($query) => $query->where($attributes['column'], $attributes['value']))
            ->when($extraColumn && $extraColumnValue, fn($query) => $query->whereIn($extraColumn, $extraColumnValue))
            ->when(($attributes['whereNotInColumn'] ?? null), fn($query) => $query->whereNotIn($attributes['whereNotInColumn'], $attributes['whereNotInValue']))
            ->when(($attributes['withAvgRelation'] ?? null), fn($query) => $query->withAvg($attributes['withAvgRelation'], $attributes['withAvgColumn']))
            ->when(($attributes['type'] ?? null), fn($query) => $query->type($attributes['type']))
            ->latest();

        if ($dynamic_page) {
            return $query->paginate(perPage: $limit, page: $offset);
        }

        return $query->paginate($limit)->appends($queryParams);
    }

    /**
     * @param string $column
     * @param string|int $value
     * @param array $attributes
     * @return mixed|Model
     */
    public function getBy(string $column, int|string $value, array $attributes = []): mixed
    {
        $extraColumn = $attributes['column_name'] ?? null;
        $extraColumnValue = $attributes['column_value'] ?? null;

        return $this->trip
            ->query()
            ->when(($attributes['relations'] ?? null), fn($query) => $query->with($attributes['relations']))
            ->when(($attributes['fare_biddings'] ?? null), fn($query) => $query->with([
                'fare_biddings' => fn($query) => $query->where('driver_id', $attributes['fare_biddings'])
            ]))
            ->when($column && $value, fn($query) => $query->where($column, $value))
            ->when($extraColumn, fn($query) => $query->where($extraColumn, $extraColumnValue))
            ->when($attributes['latest'] ?? null, fn($query) => $query->latest())
            ->when(($attributes['whereNotInColumn'] ?? null), fn($query) => $query->whereNotIn($attributes['whereNotInColumn'], $attributes['whereNotInValue']))
            ->when(($attributes['withAvgRelation'] ?? null), fn($query) => $query->withAvg($attributes['withAvgRelation'], $attributes['withAvgColumn']))
            ->when(($attributes['withTrashed'] ?? null), fn($query) => $query->withTrashed())
            ->latest()
            ->first();
    }

    /**
     * Store trip request (supports BOTH schemas):
     * 1) Old spatial schema: trip_request_coordinates has pickup_coordinates/start/destination/etc
     * 2) New json schema:   trip_request_coordinates has pickup_location/dropoff_location/polyline/distance_km/duration_min/provider/raw_response
     */
    public function store(array $attributes): Model
    {
        try {
            DB::beginTransaction();

            $trip = $this->trip;

            $trip->customer_id = $attributes['customer_id'] ?? null;
            $trip->vehicle_category_id = $attributes['vehicle_category_id'] ?? null;
            $trip->zone_id = $attributes['zone_id'] ?? null;
            $trip->area_id = $attributes['area_id'] ?? null;

            $trip->actual_fare = $attributes['actual_fare'] ?? 0;
            $trip->estimated_fare = $attributes['estimated_fare'] ?? 0;
            $trip->return_fee = $attributes['return_fee'] ?? 0;
            $trip->cancellation_fee = $attributes['cancellation_fee'] ?? 0;

            $trip->extra_fare_fee = $attributes['extra_fare_fee'] ?? 0;
            $trip->extra_fare_amount = $attributes['extra_fare_amount'] ?? 0;
            $trip->rise_request_count = $attributes['rise_request_count'] ?? 0;

            $trip->estimated_distance = isset($attributes['estimated_distance'])
                ? str_replace(',', '', (string)$attributes['estimated_distance'])
                : null;

            $trip->payment_method = $attributes['payment_method'] ?? null;
            $trip->note = $attributes['note'] ?? null;
            $trip->type = $attributes['type'];
            $trip->entrance = $attributes['entrance'] ?? null;

            // Keep existing field name used in code
            $trip->encoded_polyline = $attributes['encoded_polyline'] ?? null;

            $trip->save();

            $trip->tripStatus()->create([
                'customer_id' => $attributes['customer_id'] ?? null,
                'pending' => now(),
            ]);

            // --- Coordinate write: detect schema ---
            $hasSpatialPickup = Schema::hasColumn('trip_request_coordinates', 'pickup_coordinates');
            $hasJsonPickup = Schema::hasColumn('trip_request_coordinates', 'pickup_location');

            /**
             * Normalize intermediate inputs:
             * - Accept: null, '', '[]', '"[]"', JSON string, or array
             * - Returns JSON string for safe decoding
             */
            $normalizeJsonArray = function ($value): ?string {
                if ($value === null) {
                    return null;
                }

                if (is_array($value)) {
                    return json_encode($value);
                }

                $value = trim((string)$value);
                if ($value === '') {
                    return null;
                }

                // If it's a JSON-encoded string like '"[]"' decode once
                if (strlen($value) >= 2 && $value[0] === '"' && $value[strlen($value) - 1] === '"') {
                    $decodedOnce = json_decode($value, true);
                    if (json_last_error() === JSON_ERROR_NONE) {
                        if (is_array($decodedOnce)) {
                            return json_encode($decodedOnce);
                        }
                        if (is_string($decodedOnce)) {
                            $value = trim($decodedOnce);
                        }
                    }
                }

                $decoded = json_decode($value, true);
                if (json_last_error() === JSON_ERROR_NONE && is_array($decoded)) {
                    return json_encode($decoded);
                }

                return null;
            };

            /**
             * Decode JSON into an ARRAY safely.
             * Handles double-encoded JSON like '"[]"' that would otherwise become a string "[]".
             */
            $decodeToArray = function (?string $json): array {
                if ($json === null) return [];
                $json = trim($json);
                if ($json === '') return [];

                $decoded = json_decode($json, true);
                if (json_last_error() !== JSON_ERROR_NONE) {
                    return [];
                }

                if (is_array($decoded)) {
                    return $decoded;
                }

                // If it decoded to a string like "[]", decode again
                if (is_string($decoded)) {
                    $decoded2 = json_decode($decoded, true);
                    if (json_last_error() === JSON_ERROR_NONE && is_array($decoded2)) {
                        return $decoded2;
                    }
                }

                return [];
            };

            if ($hasSpatialPickup) {
                // OLD SPATIAL SCHEMA
                $coordinates = [
                    'pickup_coordinates' => $attributes['pickup_coordinates'],
                    'start_coordinates' => $attributes['pickup_coordinates'],
                    'destination_coordinates' => $attributes['destination_coordinates'],
                    'pickup_address' => $attributes['pickup_address'] ?? null,
                    'destination_address' => $attributes['destination_address'] ?? null,
                    'customer_request_coordinates' => $attributes['customer_request_coordinates'] ?? null,
                ];

                // Intermediate points are optional - DO NOT hard-index
                $rawIntermediate = $attributes['intermediate_coordinates'] ?? null;
                $int_coordinates = $rawIntermediate !== null && $rawIntermediate !== ''
                    ? json_decode($rawIntermediate, true)
                    : null;

                if (is_array($int_coordinates)) {
                    foreach ($int_coordinates as $key => $ic) {
                        if (!is_array($ic) || count($ic) < 2) continue;
                        if ($key == 0) {
                            $coordinates['int_coordinate_1'] = new Point($ic[0], $ic[1]);
                        } elseif ($key == 1) {
                            $coordinates['int_coordinate_2'] = new Point($ic[0], $ic[1]);
                        }
                    }
                }

                $normalizedIntermediate = $normalizeJsonArray($rawIntermediate) ?? '[]';
                $normalizedIntermediateAddresses = $normalizeJsonArray($attributes['intermediate_addresses'] ?? null) ?? '[]';

                // IMPORTANT: always store as ARRAY (prevents DB value becoming '"[]"' )
                $coordinates['intermediate_coordinates'] = $decodeToArray($normalizedIntermediate);
                $coordinates['intermediate_addresses'] = $decodeToArray($normalizedIntermediateAddresses);

                $trip->coordinate()->create($coordinates);
            } elseif ($hasJsonPickup) {
                // NEW JSON SCHEMA
                $pickupPoint = $attributes['pickup_coordinates'] ?? null;
                $dropoffPoint = $attributes['destination_coordinates'] ?? null;

                // Normalize raw_response (allow array/object JSON, or a JSON string, or null)
                $raw = $attributes['raw_response'] ?? null;
                if (is_string($raw)) {
                    $rawTrim = trim($raw);
                    if (strlen($rawTrim) >= 2 && $rawTrim[0] === '"' && $rawTrim[strlen($rawTrim) - 1] === '"') {
                        $decodedOnce = json_decode($rawTrim, true);
                        if (json_last_error() === JSON_ERROR_NONE) {
                            $raw = $decodedOnce;
                        }
                    } else {
                        $decoded = json_decode($rawTrim, true);
                        if (json_last_error() === JSON_ERROR_NONE) {
                            $raw = $decoded;
                        }
                    }
                }

                $pickupJson = $this->pointToJsonLocation(
                    point: $pickupPoint,
                    address: $attributes['pickup_address'] ?? null
                );

                $dropoffJson = $this->pointToJsonLocation(
                    point: $dropoffPoint,
                    address: $attributes['destination_address'] ?? null
                );

                $trip->coordinate()->create([
                    'pickup_location' => $pickupJson ? json_encode($pickupJson) : null,
                    'dropoff_location' => $dropoffJson ? json_encode($dropoffJson) : null,
                    'polyline' => $attributes['encoded_polyline'] ?? null,
                    'distance_km' => isset($attributes['estimated_distance'])
                        ? (float)str_replace(',', '', (string)$attributes['estimated_distance'])
                        : null,
                    'duration_min' => isset($attributes['estimated_time'])
                        ? (int)str_replace(',', '', (string)$attributes['estimated_time'])
                        : null,
                    'provider' => $attributes['provider'] ?? null,
                    'raw_response' => $raw,
                ]);
            } else {
                // Unknown schema - skip coordinate create rather than hard-crash
            }

            $trip->fee()->create();

            $trip->time()->create([
                'estimated_time' => isset($attributes['estimated_time'])
                    ? str_replace(',', '', (string)$attributes['estimated_time'])
                    : null,
            ]);

            if (($attributes['type'] ?? null) === 'parcel') {
                $trip->parcel()->create([
                    'payer' => $attributes['payer'] ?? null,
                    'weight' => $attributes['weight'] ?? null,
                    'parcel_category_id' => $attributes['parcel_category_id'] ?? null,
                ]);

                $sender = [
                    'name' => $attributes['sender_name'] ?? null,
                    'contact_number' => $attributes['sender_phone'] ?? null,
                    'address' => $attributes['sender_address'] ?? null,
                    'user_type' => 'sender',
                ];

                $receiver = [
                    'name' => $attributes['receiver_name'] ?? null,
                    'contact_number' => $attributes['receiver_phone'] ?? null,
                    'address' => $attributes['receiver_address'] ?? null,
                    'user_type' => 'receiver',
                ];

                $trip->parcelUserInfo()->createMany([$sender, $receiver]);
            }

            DB::commit();
        } catch (\Exception $e) {
            DB::rollback();
            abort(403, message: $e->getMessage());
        }

        return $this->trip;
    }

    /**
     * Converts a Point or array into a consistent JSON payload for pickup_location/dropoff_location.
     * Supports:
     * - Point object (MatanYadaev)
     * - ['lat'=>..,'lng'=>..] OR ['latitude'=>..,'longitude'=>..]
     * - ['coordinates'=>[lat,lng]] etc (best-effort)
     */
    private function pointToJsonLocation(mixed $point, ?string $address = null): ?array
    {
        if ($point instanceof Point) {
            $lat = $point->latitude;
            $lng = $point->longitude;

            return [
                'address' => $address,
                'lat' => (float)$lat,
                'lng' => (float)$lng,
            ];
        }

        if (is_array($point)) {
            $lat = $point['lat'] ?? $point['latitude'] ?? null;
            $lng = $point['lng'] ?? $point['longitude'] ?? null;

            if ($lat === null && isset($point['coordinates']) && is_array($point['coordinates']) && count($point['coordinates']) >= 2) {
                // Your API output shows [lat, lng] in "coordinates"
                $lat = $point['coordinates'][0];
                $lng = $point['coordinates'][1];
            }

            if ($lat !== null && $lng !== null) {
                return [
                    'address' => $address,
                    'lat' => (float)$lat,
                    'lng' => (float)$lng,
                ];
            }
        }

        return null;
    }

    /**
     * @param array $attributes
     * @param string $id
     * @return Model
     */
    public function update(array $attributes, string $id): Model
    {
        $trip = $this->trip->firstWhere($attributes['column'], $id);

        $__from_status = strtolower(trim((string)($trip->current_status ?? '')));

        $trip_request_keys = [
            'customer_id', 'driver_id', 'vehicle_category_id', 'vehicle_id', 'zone_id', 'estimated_fare', 'actual_fare',
            'extra_fare_amount', 'estimated_distance', 'paid_fare', 'actual_distance', 'accepted_by', 'payment_method',
            'payment_status', 'coupon_id', 'coupon_amount', 'vat_tax', 'additional_charge', 'trx_id', 'note', 'otp',
            'rise_request_count', 'type', 'current_status', 'tips', 'is_paused', 'map_screenshot',
        ];

        DB::transaction(function () use ($trip_request_keys, $attributes, $trip, $__from_status) {
            foreach ($trip_request_keys as $key) {
                if ($attributes['rise_request_count'] ?? null) {
                    $trip->increment('rise_request_count');
                } else {
                    ($attributes[$key] ?? null) ? $trip->$key = $attributes[$key] : null;
                }
            }

            ($attributes['map_screenshot'] ?? null)
                ? $trip->map_screenshot = fileUploader('trip/screenshots/', 'png', $attributes['map_screenshot'], $trip->map_screenshot)
                : null;

            $trip->save();

            if ($attributes['tripStatus'] ?? null) {
                $from = $__from_status;
                $to   = strtolower(trim((string)($attributes['current_status'] ?? '')));



                $requiresDriver = in_array($to, [
                    'accepted',
                    'out_for_pickup',
                    'picked_up',
                    'ongoing',
                    'completed',
                    'returning',
                    'returned',
                ], true);

                $driver_for_status = $attributes['driver_id'] ?? $trip->driver_id ?? null;

                if ($requiresDriver && empty($driver_for_status)) {
                    \Illuminate\Support\Facades\Log::warning('Blocked status change without driver_id', [
                        'trip_id' => $trip->id,
                        'from'    => $from,
                        'to'      => $to,
                    ]);

                    throw \Illuminate\Validation\ValidationException::withMessages([
                        'trip_status' => ["Cannot set status '{$to}' without a driver assigned."],
                    ]);
                }


                if ($to && $to !== $from) {
                    if (!\Modules\TripManagement\Lib\TripStatusTransition::isValidColumn($to)) {
                        \Illuminate\Support\Facades\Log::warning('Trip status invalid column (transaction path)', [
                            'trip_id' => $trip->id,
                            'to' => $to,
                        ]);

                        throw \Illuminate\Validation\ValidationException::withMessages([
                            'current_status' => ["Invalid trip status: {$to}"],
                        ]);
                    }

                    if (!\Modules\TripManagement\Lib\TripStatusTransition::canTransition($from, $to)) {
                        \Illuminate\Support\Facades\Log::warning('Trip status transition blocked (transaction path)', [
                            'trip_id' => $trip->id,
                            'from' => $from,
                            'to' => $to,
                        ]);

                        throw \Illuminate\Validation\ValidationException::withMessages([
                            'current_status' => ["Invalid status transition: {$from} -> {$to}"],
                        ]);
                    }

                    // Keep trip table in sync too
                    $trip->current_status = $to;
                    $trip->save();

                    $__pending_ts = $trip->created_at ?? now();


                    $exists = \Illuminate\Support\Facades\DB::table('trip_status')
                        ->where('trip_request_id', $trip->id)
                        ->exists();

                    if ($exists) {
                        $driver_for_status = $attributes['driver_id'] ?? $trip->driver_id ?? null;

                        $payload = [
                            'customer_id' => $trip->customer_id,
                            $to           => now(),
                            'updated_at'  => now(),
                        ];

                        // Only set driver_id if we actually have one; never overwrite with null.
                        if (!empty($driver_for_status)) {
                            $payload['driver_id'] = $driver_for_status;
                        }

                        \Illuminate\Support\Facades\DB::table('trip_status')
                            ->where('trip_request_id', $trip->id)
                            ->update($payload);
                    } else {
                        $driver_for_status = $attributes['driver_id'] ?? $trip->driver_id ?? null;
                        $payload = [
                            'trip_request_id' => $trip->id,
                            'customer_id'     => $trip->customer_id,
                            // backfill pending using trip created_at (best proxy)
                            'pending'         => $__pending_ts,
                            $to               => now(),
                            'created_at'      => $__pending_ts,
                            'updated_at'      => now(),
                        ];

                        // Only set driver_id if we actually have one; never insert null.
                        if (!empty($driver_for_status)) {
                            $payload['driver_id'] = $driver_for_status;
                        }

                        \Illuminate\Support\Facades\DB::table('trip_status')->insert($payload);
                    }
                }
            }
            if ($attributes['driver_arrival_time'] ?? null) {
                $trip->time()->update(['driver_arrival_time' => $attributes['driver_arrival_time']]);
            }

            if ($attributes['coordinate'] ?? null) {
                $trip->coordinate()->update($attributes['coordinate']);
            }
        });

        return $trip;
    }

    public function destroy(string $id): Model
    {
        $trip = $this->trip->query()->find($id);
        $trip->delete();
        return $trip;
    }

    public function updateRelationalTable($attributes): mixed
    {
        $trip = $this->getBy(column: $attributes['column'], value: $attributes['value']);

        if ($attributes["trip_status"] ?? null) {
            $from = strtolower(trim((string)$trip->current_status));
            $to   = strtolower(trim((string)$attributes["trip_status"]));



                $requiresDriver = in_array($to, [
                    'accepted',
                    'out_for_pickup',
                    'picked_up',
                    'ongoing',
                    'completed',
                    'returning',
                    'returned',
                ], true);

                $driver_for_status = $attributes['driver_id'] ?? $trip->driver_id ?? null;

                if ($requiresDriver && empty($driver_for_status)) {
                    \Illuminate\Support\Facades\Log::warning('Blocked status change without driver_id', [
                        'trip_id' => $trip->id,
                        'from'    => $from,
                        'to'      => $to,
                    ]);

                    throw \Illuminate\Validation\ValidationException::withMessages([
                        'trip_status' => ["Cannot set status '{$to}' without a driver assigned."],
                    ]);
                }


            // If status is unchanged, no-op
            if ($to !== $from) {
                if (!\Modules\TripManagement\Lib\TripStatusTransition::isValidColumn($to)) {
                    \Illuminate\Support\Facades\Log::warning('Trip status invalid column', [
                        'trip_id' => $trip->id,
                        'to' => $to,
                    ]);

                    throw \Illuminate\Validation\ValidationException::withMessages([
                        'trip_status' => ["Invalid trip status: {$to}"],
                    ]);
                }

                if (!\Modules\TripManagement\Lib\TripStatusTransition::canTransition($from, $to)) {
                    \Illuminate\Support\Facades\Log::warning("Trip status transition blocked", [
                        "trip_id" => $trip->id,
                        "from" => $from,
                        "to" => $to,
                    ]);

                    throw \Illuminate\Validation\ValidationException::withMessages([
                        "trip_status" => ["Invalid status transition: {$from} -> {$to}"],
                    ]);
                }

                $trip->current_status = $to;
                $trip->save();

                $__pending_ts = $trip->created_at ?? now();

                    $exists = \Illuminate\Support\Facades\DB::table('trip_status')
                        ->where('trip_request_id', $trip->id)
                        ->exists();

                    if ($exists) {
                        $driver_for_status = $attributes['driver_id'] ?? $trip->driver_id ?? null;

                        $payload = [
                            'customer_id' => $trip->customer_id,
                            $to           => now(),
                            'updated_at'  => now(),
                        ];

                        // Only set driver_id if we actually have one; never overwrite with null.
                        if (!empty($driver_for_status)) {
                            $payload['driver_id'] = $driver_for_status;
                        }

                        \Illuminate\Support\Facades\DB::table('trip_status')
                            ->where('trip_request_id', $trip->id)
                            ->update($payload);
                    } else {
                        $driver_for_status = $attributes['driver_id'] ?? $trip->driver_id ?? null;
                        $payload = [
                            'trip_request_id' => $trip->id,
                            'customer_id'     => $trip->customer_id,
                            // backfill pending using trip created_at (best proxy)
                            'pending'         => $__pending_ts,
                            $to               => now(),
                            'created_at'      => $__pending_ts,
                            'updated_at'      => now(),
                        ];

                        // Only set driver_id if we actually have one; never insert null.
                        if (!empty($driver_for_status)) {
                            $payload['driver_id'] = $driver_for_status;
                        }

                        \Illuminate\Support\Facades\DB::table('trip_status')->insert($payload);
                    }
            }
        }

        if ($attributes['trip_cancellation_reason'] ?? null) {
            $trip->trip_cancellation_reason = $attributes['trip_cancellation_reason'];
            $trip->save();
        }

        // Driver assignment/unassignment behavior:
        // - Only unassign when explicitly requested.
        // - Do NOT wipe driver_id just because the key exists.
        if (!empty($attributes['unassign_driver']) && $attributes['unassign_driver'] === true) {
            $trip->driver_id = null;
            $trip->save();
        } elseif (array_key_exists('driver_id', $attributes) && $attributes['driver_id']) {
            $trip->driver_id = $attributes['driver_id'];
            $trip->save();
        }


        if ($attributes['coordinate'] ?? null) {
            $coordinate = $trip->coordinate;
            if ($coordinate) {
                $coordinate->update([
                    'drop_coordinates' => $attributes['coordinate']['drop_coordinates'],
                ]);
                $coordinate->save();
            }
        }

        if ($attributes['fee'] ?? null) {
            $trip->fee()->update($attributes['fee']);
        }

        return $trip->tripStatus;
    }

    /**
     * DRIVER: pending rides list
     * - If spatial column exists => keep distanceSphere filtering
     * - If NOT => return pending rides in zone (no distance filter) to avoid empty lists / crashes
     */
    public function getPendingRides($attributes): mixed
    {
        $hasSpatialPickup = Schema::hasColumn('trip_request_coordinates', 'pickup_coordinates');

        $query = $this->trip
            ->when($attributes['relations'] ?? null, fn($query) => $query->with($attributes['relations']))
            ->with([
                'fare_biddings' => fn($query) => $query->where('driver_id', auth()->id()),
                'coordinate' => function ($query) use ($attributes, $hasSpatialPickup) {
                    if ($hasSpatialPickup && ($attributes['driver_locations'] ?? null) && ($attributes['distance'] ?? null)) {
                        $query->distanceSphere('pickup_coordinates', $attributes['driver_locations'], $attributes['distance']);
                    }
                },
            ])
            ->when(
                $hasSpatialPickup && ($attributes['driver_locations'] ?? null) && ($attributes['distance'] ?? null),
                fn($q) => $q->whereHas('coordinate', fn($qq) => $qq->distanceSphere('pickup_coordinates', $attributes['driver_locations'], $attributes['distance']))
            )
            ->whereDoesntHave('ignoredRequests', fn($query) => $query->where('user_id', auth()->id()))
            ->where(fn($query) => $query->where('vehicle_category_id', $attributes['vehicle_category_id'])->orWhereNull('vehicle_category_id'))
            ->where('zone_id', $attributes['zone_id'])
            ->where('current_status', PENDING)
            ->where(function ($query) use ($attributes) {
                if (($attributes['ride_count'] ?? 0) < 1) {
                    $query->where('type', RIDE_REQUEST);
                }

                $query->orWhere(function ($query) use ($attributes) {
                    if (($attributes['parcel_follow_status'] ?? false)) {
                        if (($attributes['parcel_count'] ?? 0) < ($attributes['max_parcel_request_accept_limit'] ?? 0)) {
                            $query->where('type', PARCEL);
                        } else {
                            $query->whereNotIn('type', [PARCEL, RIDE_REQUEST]);
                        }
                    } else {
                        $query->where('type', PARCEL);
                    }
                });
            });

        return $query->orderBy('created_at', 'desc')
            ->paginate(perPage: $attributes['limit'], page: $attributes['offset']);
    }

    public function leaderBoard(array $attributes)
    {
        return $this->trip
            ->query()
            ->whereHas('driver', fn($query) => $query->where('deleted_at', null))
            ->whereHas('customer', fn($query) => $query->where('deleted_at', null))
            ->when(($attributes['relations'] ?? null), fn($query) => $query->with($attributes['relations']))
            ->when(($attributes['whereNotNull'] ?? null), fn($query) => $query->whereNotNull($attributes['whereNotNull']))
            ->when(($attributes['selectRaw'] ?? null), fn($query) => $query->selectRaw($attributes['selectRaw']))
            ->when(($attributes['groupBy'] ?? null), fn($query) => $query->groupBy($attributes['groupBy']))
            ->when(($attributes['orderBy'] ?? null), fn($query) => $query->orderBy($attributes['orderBy'], $attributes['direction'] ?? 'asc'))
            ->when(($attributes['start'] ?? null), fn($query) => $query->whereBetween('created_at', [$attributes['start'], $attributes['end']]))
            ->paginate(perPage: $attributes['limit'], page: $attributes['offset']);
    }

    public function getStat(array $attributes)
    {
        $query = $this->trip
            ->where($attributes['column'], $attributes['value'])
            ->when(($attributes['from'] ?? null), fn($query) => $query->whereBetween('created_at', [$attributes['from'], $attributes['to']]));

        if ($attributes['sum'] ?? null) {
            return $query->sum($attributes['sum']);
        }
        if ($attributes['count'] ?? null) {
            return $query->count($attributes['count']);
        }
        return null;
    }

    public function getIncompleteRide(array $attributes = []): mixed
    {
        return $this->trip
            ->query()
            ->when(($attributes['relations'] ?? null), fn($query) => $query->with($attributes['relations']))
            ->where(fn($query) => $query->whereNotIn('current_status', ['completed', 'cancelled'])
                ->orWhere(fn($query) => $query->whereNotNull('driver_id')
                    ->whereHas('fee', function ($query) {
                        $query->where('cancelled_by', '!=', 'driver');
                    })
                    ->whereIn('current_status', ['completed', 'cancelled'])
                    ->where('payment_status', 'unpaid')
                ))
            ->when(($attributes['type'] ?? null), fn($query) => $query->where('type', $attributes['type']))
            ->where($attributes['column'], $attributes['value'])
            ->first();
    }

    public function overviewStat(array $attributes)
    {
        return $this->trip->query()
            ->when($attributes['from'] ?? null, fn($query) => $query->whereBetween('created_at', [$attributes['from'], $attributes['to']]))
            ->selectRaw('current_status, count(*) as total_records')
            ->groupBy('current_status')
            ->get();
    }

    public function trashed(array $attributes)
    {
        $search = $attributes['search'] ?? null;

        return $this->trip->query()
            ->when($search, function ($query) use ($search) {
                $query->where(function ($query) use ($search) {
                    $keys = explode(' ', $search);
                    foreach ($keys as $key) {
                        $query->where('ref_id', 'like', '%' . $key . '%');
                    }
                });
            })
            ->onlyTrashed()
            ->paginate(paginationLimit());
    }

    public function restore(string $id)
    {
        return $this->trip->query()->onlyTrashed()->find($id)->restore();
    }

    public function pendingParcelList(array $attributes, string $type)
    {
        if ($type == "driver") {
            return $this->trip->query()
                ->with([
                    'customer', 'driver', 'vehicleCategory', 'vehicleCategory.tripFares', 'vehicle', 'coupon', 'time',
                    'coordinate', 'fee', 'tripStatus', 'zone', 'vehicle.model', 'fare_biddings', 'parcel', 'parcelUserInfo'
                ])
                ->where(['type' => 'parcel', $attributes['column'] => $attributes['value']])
                ->when($attributes['whereNotNull'] ?? null, fn($query) => $query->whereNotNull($attributes['whereNotNull']))
                ->where(function ($query) {
                    $query->where(function ($query1) {
                        $query1->where('current_status', COMPLETED)->where('payment_status', UNPAID);
                    })->orWhere(function ($query) {
                        $query->whereIn('current_status', [PENDING, ACCEPTED, ONGOING, RETURNING]);
                    });
                })
                ->paginate(perPage: $attributes['limit'], page: $attributes['offset']);
        }

        return $this->trip->query()
            ->with([
                'customer', 'driver', 'vehicleCategory', 'vehicleCategory.tripFares', 'vehicle', 'coupon', 'time',
                'coordinate', 'fee', 'tripStatus', 'zone', 'vehicle.model', 'fare_biddings', 'parcel', 'parcelUserInfo'
            ])
            ->where(['type' => 'parcel', $attributes['column'] => $attributes['value']])
            ->when($attributes['whereNotNull'] ?? null, fn($query) => $query->whereNotNull($attributes['whereNotNull']))
            ->whereNotIn('current_status', [CANCELLED, COMPLETED, RETURNED])
            ->paginate(perPage: $attributes['limit'], page: $attributes['offset']);
    }

    public function unpaidParcelRequest(array $attributes)
    {
        return $this->trip->query()
            ->with([
                'customer', 'driver', 'vehicleCategory', 'vehicleCategory.tripFares', 'vehicle', 'coupon', 'time',
                'coordinate', 'fee', 'tripStatus', 'zone', 'vehicle.model', 'fare_biddings', 'parcel', 'parcelUserInfo'
            ])
            ->whereNotNull('driver_id')
            ->where([
                'type' => 'parcel',
                $attributes['column'] => $attributes['value'],
                'payment_status' => UNPAID
            ])
            ->when($attributes['whereHas'] ?? null, fn($query) => $query->whereHas('parcel', fn($query) => $query->where('payer', 'sender')))
            ->paginate(perPage: $attributes['limit'], page: $attributes['offset']);
    }

    public function getPopularTips()
    {
        return $this->trip->query()
            ->whereNot('tips', 0)
            ->groupBy('tips')
            ->selectRaw('tips, count(*) as total')
            ->orderBy('total', 'desc')
            ->first();
    }
}
